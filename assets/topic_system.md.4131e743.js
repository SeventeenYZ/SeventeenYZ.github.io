import{_ as e,c as d,o as c,a as o}from"./app.a15f6e39.js";const j=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"浏览器","slug":"浏览器","link":"#浏览器","children":[]},{"level":2,"title":"前后端分离","slug":"前后端分离","link":"#前后端分离","children":[]},{"level":2,"title":"Node","slug":"node","link":"#node","children":[]},{"level":2,"title":"模块化","slug":"模块化","link":"#模块化","children":[]},{"level":2,"title":"框架","slug":"框架","link":"#框架","children":[]},{"level":2,"title":"工程化","slug":"工程化","link":"#工程化","children":[]},{"level":2,"title":"跨端","slug":"跨端","link":"#跨端","children":[]},{"level":2,"title":"大前端","slug":"大前端","link":"#大前端","children":[]},{"level":2,"title":"网络","slug":"网络","link":"#网络","children":[]},{"level":2,"title":"运维","slug":"运维","link":"#运维","children":[]},{"level":2,"title":"补充知识点1","slug":"补充知识点1","link":"#补充知识点1","children":[]},{"level":2,"title":"补充知识点2","slug":"补充知识点2","link":"#补充知识点2","children":[]}],"relativePath":"topic/system.md"}'),a={name:"topic/system.md"},p=o('<p>为了搭起前端知识体系的骨架，明白各类前端工具的概念，出现背景和作用</p><h2 id="浏览器" tabindex="-1">浏览器 <a class="header-anchor" href="#浏览器" aria-hidden="true">#</a></h2><p>本质是一个解析器，渲染引擎解析<code>html</code>、<code>css</code>文件绘制出页面，<code>JavaScript</code>引擎解释执行<code>JavaScript</code></p><p>浏览器内核：以前内核的概念包括渲染引擎和<code>js</code>引擎，现在一般称渲染引擎为内核，<code>js</code>引擎独立称呼，例如：以前称chrome浏览器使用chromium内核，blink渲染引擎，v8<code>js</code>引擎，现在称chrome浏览器使用blink内核（渲染引擎），v8<code>js</code>引擎</p><h2 id="前后端分离" tabindex="-1">前后端分离 <a class="header-anchor" href="#前后端分离" aria-hidden="true">#</a></h2><p>前后端耦合时期：浏览器通过<code>url</code>定位，服务器返回<code>html</code>页面，可以是静态的，也可以是后端拼接的<code>JSP</code>、<code>PHP</code>页面并解析成的，此时前后端项目代码也是耦合在一起的</p><p>前后端分离时期：浏览器通过<code>ajax</code>发送请求，前端拿到响应回来的数据后自己填充页面</p><p><code>JQuery</code>：对<code>JavaScript</code>进行封装的一个函数库，早期开发模式是基于浏览器的<code>dom api</code>来做渲染和交互，<code>JQuery</code>简化了<code>dom</code>操作，抹平不同浏览器不同版本间的差异</p><p><code>XMLHttpRequest</code>：一开始是99年IE5的非标准出现，后来各浏览器跟进实现，06年才正式成为<code>web</code>标准，它的出现表示浏览器允许<code>JavaScript</code>发出<code>http</code>请求，为后来的<code>Ajax</code>应用创造了前置条件</p><p><code>Ajax</code>：传统网页如果更新内容会重载整个页面，<code>Ajax</code>技术通过<code>XMLHttpRequest</code>对象来向服务器发送异步请求并从服务端获取数据，网页可在不重载的情况下更新数据，促进了后面的前后端分离</p><p>模板引擎：后端使用<code>PHP</code>、<code>JSP</code>等技术，通过模板引擎填充数据（例如<code>.jsp</code>文件，格式和<code>.html</code>文件类似，数据显示部分用<code>Java</code>语言填充），并解析成<code>.html</code>文件返回给浏览器渲染，这是最早的服务端渲染</p><p>额外关键词：MVC架构</p><h2 id="node" tabindex="-1">Node <a class="header-anchor" href="#node" aria-hidden="true">#</a></h2><p>一开始，<code>JavaScript</code>这门语言只能在浏览器中被解析，这是因为<code>Javascript</code>语言需要由内置于浏览器中的<code>Javascript</code>引擎解析为电脑能够理解的机器码并执行</p><p><code>Ryan Dahl</code>将谷歌浏览器的<code>Javascript</code>引擎（V8引擎）从浏览器中取出，并在其之上实现了更多功能，使<code>Javascript</code>拥有了独立于浏览器的运行环境，这就是<code>Node.js</code></p><p><code>Node.js</code>和工程化：前端项目的构建工具在<code>node.js</code>出现之前是不足的，主要原因是跑在浏览器里的<code>js runtime</code>跳不出浏览器这个沙盒，无法直接操作文件，而这是构建工具必备的底层功能，那时候<code>js</code>不是一种系统编程语言，<code>web</code>开发社区没有足够的动力去用一种非<code>js</code>的系统编程语言去开发各类构建工具（那时候可以用<code>Python</code>、<code>Java</code>、<code>Ruby</code>或<code>PHP</code>去写工具，只是当时会的前端太少），<code>Node.js</code>的出现让<code>js</code>跳出了浏览器这个沙盒，可以进行系统调用，把它变成了一种系统编程语言，而熟悉<code>js</code>的开发人员就有动力去实现各种工具了</p><p>不过现在有些构建工具已经不用<code>js</code>写了，例如<code>Rust</code>写的<code>swc</code>代替<code>babel</code>，<code>go</code>写的<code>esbuild</code></p><h2 id="模块化" tabindex="-1">模块化 <a class="header-anchor" href="#模块化" aria-hidden="true">#</a></h2><p>随着项目的增长，一个页面有多个<code>script</code>标签，带来很多依赖关系，命名污染上的问题，于是要让前端模块化，各种模块化规范接连出现</p><p><code>CommonJS</code>：用于Node应用上的模块化规范，但是是同步加载，不适合浏览器端使用</p><p><code>AMD</code>、<code>CMD</code>：用于浏览器端，可异步加载</p><p><code>ES Modules</code>：ES6在语言标准的层面上实现了模块化功能，取代以上规范，成为浏览器和服务器通用的模块解决方案</p><h2 id="框架" tabindex="-1">框架 <a class="header-anchor" href="#框架" aria-hidden="true">#</a></h2><p><code>React</code>、<code>Vue</code>：<code>UI=f(state)</code>，只需操作状态数据，页面会自动更新</p><p>传统页面应用：也叫多页面应用，当客户端发起页面请求后，后端收到请求，然后取出数据库中的数据，组装好 <code>HTML</code>，然后返回 <code>HTML</code>、 <code>css</code>和 <code>JavaScript</code>。有了 <code>Ajax</code> 后，我们在当前页面可以重新获取数据，并更新页面内容。但当我们切换页面，也就是有页面跳转时，整个过程会从头再来一次</p><p><code>SPA</code>：单页面应用，切换页面不用整个页面刷新，所有的资源只在第一次页面请求时被加载，后面都只会发起 <code>Ajax</code>请求获取数据而已</p><p><code>路由</code>：<code>SPA</code>应用的核心，切换<code>url</code>，客户端的<code>JavaScript</code>拦截页面的跳转请求，匹配对应的页面组件，动态获取新的数据，然后在无需重新加载的情况下更新当前页面</p><p><code>状态管理</code>：集中式管理应用的状态，借鉴<code>Flux</code>架构，使状态的改变可追溯</p><p><code>SSR</code>：服务端渲染，解决了<code>CSR</code>（客户端渲染）应用首屏渲染时间长，<code>SEO</code>差的问题，本质是启动<code>node</code>服务器，当浏览器向<code>node</code>服务器获取<code>html</code>时，由<code>node</code>服务器去向后端服务器获取数据，然后进行拼接完返回给浏览器</p><p><code>Rendora </code>：为了解决<code>SPA</code>项目的<code>SEO</code>处理，请求经过 <code>Rendora </code>的时候它会根据请求头 <code>user-agent</code> 来判断请求是属于爬虫还是普通用户，普通用户直接代理到原有的<code>Web</code>服务器，而爬虫的请求会经过无头浏览器(head-less browser) 处理生成一张页面返回给爬虫，而这个页面的内容可以理解为是运行时的 DOM 快照</p><p>额外关键词：MVVM架构</p><h2 id="工程化" tabindex="-1">工程化 <a class="header-anchor" href="#工程化" aria-hidden="true">#</a></h2><p>传统的前端开发模式存在一系列问题，于是涌现了许多工具来解决，前端逐渐进入工程化</p><p>脚手架：<code>Vue CLI</code>、<code>create-react-app</code></p><p>依赖管理：<code>npm</code>、<code>yarn</code>、<code>pnpm</code></p><p><code>sass</code>、<code>less</code>等预处理器增强了<code>css</code>的能力</p><p><code>css</code>、<code>JavaScript</code>代码的浏览器兼容问题：旧浏览器不识别高版本的<code>JavaScript</code>或<code>css</code>特定前缀问题，相关工具：<code>postcss</code>、<code>babel</code></p><p><code>tree-shaking</code>：打包时对使用不到的代码进行删除</p><p><code>TypeScript</code>：补充<code>JavaScript</code>动态类型的特点，减少运行时错误</p><p>代码检查和代码格式化，相关工具：<code>ESLint</code>，<code>Prettier</code></p><p><code>webpack</code>：打包工具，还有<code>loader</code>工具来转换浏览器支持的文件格式（如<code>.scss</code>转<code>.css</code>），<code>plugin</code>机制调用其它工具对代码做资源压缩、代码分割等操作</p><p><code>vite</code>：解决了<code>webpack</code>开发环境打包时间长的弊端，通过不打包，按需编译来提升开发体验，生产环境打包时通过<code>rollup</code></p><p>热更新：开发环境下修改文件保存重新编译，页面能自动更新已修改的文件</p><p><code>bundleless</code>：无打包构建，过去打包主要是因为<code>http/1.1</code>，各浏览器有并行连接限制；浏览器不支持模块系统（如CommonJS包不能直接在浏览器运行）；代码依赖关系与顺序管理。随着标准的确立，浏览器大厂和前端生态的跟进，使得不打包成为可能，主要原因有：<code>http/2.0</code>多路复用，各大浏览器逐渐支持ESM，越来越多<code>npm</code>包支持ESM</p><p>构建名词：压缩、编译、格式化、打包、代码检查、代码分割、文件合并</p><p>额外关键词：Turbopack、Rome</p><h2 id="跨端" tabindex="-1">跨端 <a class="header-anchor" href="#跨端" aria-hidden="true">#</a></h2><p>跨端：都是实现一个容器，给容器提供统一的<code>api</code>，这套<code>api</code>由不同平台各自去实现，保证功能一致，这样同一份代码能跑在不同平台的相同容器内，缺点：多了一层容器，性能比直接调用系统<code>api</code>会有所下降，当某项能力容器没有提供的时候，需要借助<code>bridge</code>进行扩展，例如<code>js</code>引擎的<code>JSbridge</code>，<code>jvm</code>的<code>jni</code>，至于编译成原生组件或内置浏览器或<code>WebView</code>去承载就由框架自己决定</p><p><code>WebView</code>：承载网页的容器，它有<code>webkit</code>渲染引擎，主要用于移动端（小程序、手机app）展示<code>html</code>页面用，相当于一个内置的浏览器（只是少了地址栏，书签栏这些<code>UI</code>控件）</p><p><code>Hybrid</code>开发：基于<code>WebView</code>开发（相当于有渲染引擎），再加上一个<code>js</code>引擎，再加上一个<code>bridge</code>可以扩展原生能力，性能会差点，例如小程序、<code>Hybrid App</code></p><p><code>React Native</code>：将<code>React</code>框架移植到了手机端，用来开发手机App，与<code>Hybrid</code>开发区别开来，<code>RN</code>是通过<code>js</code>引擎转化成原生组件的，不需要<code>WebView</code>承载</p><p><code>Electron</code>：<code>chromium</code>（相当于有渲染引擎）+ <code>Node.js</code> + 原生系统<code>api</code>，构建出兼容<code>Mac</code>、<code>Window</code>、<code>Linux</code>三个平台的应用，其它桌面端跨平台框架还有<code>tauri</code></p><p><code>Flutter</code>：使用<code>Dart</code>语言，一套代码在多个平台（IOS、Android、PC端）运行，通过跨平台的<code>Skia</code>图形库实现的渲染引擎，直接在底层进行<code>UI</code>渲染，绘制自己的<code>UI</code>组件，保证跨端的一致性，而且性能接近原生</p><h2 id="大前端" tabindex="-1">大前端 <a class="header-anchor" href="#大前端" aria-hidden="true">#</a></h2><p><code>BFF</code>：网上说得花里胡哨的，其实就是一堆胶水代码，维护性也要考虑。一般做接口聚合，参数校验，鉴权，数据转化等功能，对使用微服务架构的后端好处更多一些，适用场景：后端有稳定的领域服务，需要一个聚合层；有完整的基建：日志，链路，服务器监控，性能监控等</p><p>微前端：项目随着业务的迭代发展可能会变成一个巨石应用，微前端借鉴了微服务的理念，将一个庞大的应用拆分成多个独立的子应用，子应用不需要统一技术栈，每个应用可独立开发、运行、部署。另外也可重构老项目使用，改路由指向新项目页面，新项目的页面渐进式替换旧项目的页面，直至所有页面都重构完成，老项目下线，好处是重构新项目的同时，不用去维护旧项目中和重构页面相同的部分</p><p><code>serverless</code>：区别于传统的云服务器，传统云服务器是购买后24小时无论用不用，都得硬性付费，这样其实是很不划算的，而<code>serverless</code>采用的方案，其实购买的是计算能力，我们根据实际消耗的计算能力来付钱，没有访问就不付钱，访问少了就少付钱, 访问多了就多付钱，比如凌晨我们没有用户访问，此时是不收费的，同时因为我们购买的是技能能力，所以不存在down机的情况，不需要管服务器，突发性的高访问的时候，也不怎么用怕，因为计算能力是可以很轻松的扩展的，传统服务器这些都做不到，另外因为计算能力可扩展，那么只要数据库跟得上，同时在线用户数再多服务器也不会崩溃，传统云服务器，在用户多的时候一旦技术跟不上基本就崩了</p><p>低代码：狭义范围的低代码指通过拖拽组件生成应用的技术，广义上一切可减少代码，提升开发效率的都可称为低代码</p><p><code>WebAssembly</code>：一种新的字节码格式，高级编程语言编译成字节码放到<code>WebAssembly</code>虚拟机中才能运行，浏览器厂商需要做的就是根据<code>WebAssembly</code>规范实现虚拟机</p><h2 id="网络" tabindex="-1">网络 <a class="header-anchor" href="#网络" aria-hidden="true">#</a></h2><p><code>WebSocket</code>：双向通信，解决了服务器不能主动向浏览器发送消息的问题</p><h2 id="运维" tabindex="-1">运维 <a class="header-anchor" href="#运维" aria-hidden="true">#</a></h2><p><code>CDN</code>：在靠近用户的地方，建一个缓存服务器，把远端的内容复制一份放着，采用更多的缓存服务器（也称为CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求</p><p><code>CI/CD</code>：</p><p><code>docker</code>：</p><p><code>k8s</code></p><h2 id="补充知识点1" tabindex="-1">补充知识点1 <a class="header-anchor" href="#补充知识点1" aria-hidden="true">#</a></h2><p><code>webpack</code>依赖<code>Node.js</code>是怎么个依赖法：<code>webpack</code>是用<code>js</code>编写的工具，想在机器上跑<code>js</code>脚本，就需要有一个解释执行<code>js</code>的环境，<code>Node.js</code>出现之前只能在浏览器环境下解释执行<code>js</code>，而<code>Node.js</code>基于v8引擎进行了一系列封装，使得我们可以在非浏览器环境下解释执行<code>js</code><code>Node.js</code>支持本地文件读写，<code>webpack</code>基于此提供了编译前端代码的功能 <code>Node.js</code>可以搭建网络服务，<code>webpack</code>基于此提供了开发环境的搭建，使得我们可以轻松地在本地构建服务继而调试我们的前端项目代码 说<code>webpack</code>依赖<code>Node.js</code>不太准确，应该说<code>webpack</code>是用<code>Node.js</code>这个应用程序去执行的，因为<code>js</code>不是机器语言，解释执行<code>js</code>必须要一个特定的环境，而<code>Node.js</code>提供了这个环境</p><p>开发环境下的流程是什么样的：启动后会在本地起一个本地服务器，监听某个端口，打开开发环境<code>url</code>，本地服务器返回资源，发起请求时本地服务器起代理作用将请求转发到目标服务器上</p><h2 id="补充知识点2" tabindex="-1">补充知识点2 <a class="header-anchor" href="#补充知识点2" aria-hidden="true">#</a></h2><p>1、从输入URL到展示页面的全过程</p><p>2、前端的发展史</p><p>3、碰到一个新的工具，要以这样的思维去看待：出现背景是什么，解决了什么问题</p><p>4、项目应该是适合什么工具用什么，而不是流行什么用什么</p>',74),s=[p];function i(r,t,l,n,h,u){return c(),d("div",null,s)}const m=e(a,[["render",i]]);export{j as __pageData,m as default};
