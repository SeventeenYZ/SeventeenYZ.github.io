import{_ as e,c as a,o as t,a as n}from"./app.b100ac4a.js";const C=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"字符编码","slug":"字符编码","link":"#字符编码","children":[]},{"level":2,"title":"CPU架构","slug":"cpu架构","link":"#cpu架构","children":[]},{"level":2,"title":"机器码、汇编语言、高级语言","slug":"机器码、汇编语言、高级语言","link":"#机器码、汇编语言、高级语言","children":[{"level":3,"title":"高级语言编写的程序在各CPU架构、操作系统平台运行的做法","slug":"高级语言编写的程序在各cpu架构、操作系统平台运行的做法","link":"#高级语言编写的程序在各cpu架构、操作系统平台运行的做法","children":[]}]}],"relativePath":"Topic/computer.md"}'),r={name:"Topic/computer.md"},i=n('<h2 id="字符编码" tabindex="-1">字符编码 <a class="header-anchor" href="#字符编码" aria-hidden="true">#</a></h2><p>ASCII：8位，最多只能表示256个字符</p><p>Unicode：ASCII的超集，早期的Unicode只有16位，最多能表示65536个字符，之后出现了UTF（Universal Character Set），采用31位编码，能表示20多亿个字符，因为早期的Unicode过短，而UST过长，所以后来Unicode与UST标准开始合并（当然还有其他原因），使用U+0000-U+10FFFF（总共能编码[00,10]17*[0000,FFFF]65536个字符,区间内的字符为16进制表示）这个区间来编码字符（U+是Unicode约定的表示方式，后跟十六进制）。所以现在所指的Unicode不再是只有16位</p><p>摘自：<a href="https://www.zhihu.com/question/22881537/answer/32311983" target="_blank" rel="noreferrer">https://www.zhihu.com/question/22881537/answer/32311983</a></p><h2 id="cpu架构" tabindex="-1">CPU架构 <a class="header-anchor" href="#cpu架构" aria-hidden="true">#</a></h2><p>IA-32：32位处理器，旧的架构 x86-64：64位处理器 ARMv7：32位处理器，旧的架构 ARM64：64位处理器，可认为是ARMv8</p><h2 id="机器码、汇编语言、高级语言" tabindex="-1">机器码、汇编语言、高级语言 <a class="header-anchor" href="#机器码、汇编语言、高级语言" aria-hidden="true">#</a></h2><p>机器码在各CPU架构、操作系统平台上运行的本质：首先，电脑只能执行一条一条的机器语言，这是肯定的，也就是说无论什么语言，到最终执行时都要变成机器码，而机器码是无法跨平台的，不同CPU架构对应的<strong>指令集不同</strong>，相同CPU架构，但是系统不同（比如是windows和linux），还是不能跨平台，因为不同系统的<strong>ABI不同</strong></p><h3 id="高级语言编写的程序在各cpu架构、操作系统平台运行的做法" tabindex="-1">高级语言编写的程序在各CPU架构、操作系统平台运行的做法 <a class="header-anchor" href="#高级语言编写的程序在各cpu架构、操作系统平台运行的做法" aria-hidden="true">#</a></h3><ol><li><p>用编译器将高级语言源代码编译成特定平台上的机器码</p></li><li><p>使用解释器或虚拟机技术，例如java、python、js、C#</p></li></ol><p>C是初代高级语言，初代编译器用汇编语言实现，之后可以用C语言再写一个C语言的编译器，业界管这种做法叫Bootstrap（自举）。其它高级语言，通常来说初代编译器会选择用C/C++之类的语言编写，有了第一版的编译器之后，之后的编译器就可以用本语言来编写，不过由于编译器本身的复杂度，可能有某些组件依赖了其它语言写的组件，比如Rust现有的编译器依赖了一个C++编写的linker。绕起来就是：先用机器码写汇编的编译器，再用汇编语言重新写汇编的编译器；汇编写C的编译器，然后再用C重写C的编译器；C写Java的编译器，再用Java重写Java的编译器</p><p>虚拟机也是一个普通的应用程序，但和编译器不一样，它是负责识别代码，还负责具体执行 如：python是被一个C写的解释器解释执行，Java被一个C++写的虚拟机转化成机器码来执行（更详细点是Java源码被编译成字节码，运行的时候被虚拟机解释成机器码执行） 为什么执行python脚本的程序叫python解释器，运行java字节码的叫虚拟机。python解释器是对python脚本直接进行加载、编译和执行，而java需要预先通过java编译器将java源码编译成字节码，再交由jvm执行，jvm是字节码的解释器，而不是java的解释器</p>',12),o=[i];function c(p,s,h,l,d,u){return t(),a("div",null,o)}const v=e(r,[["render",c]]);export{C as __pageData,v as default};
