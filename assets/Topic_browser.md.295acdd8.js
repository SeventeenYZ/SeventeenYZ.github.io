import{_ as e,c as o,o as c,a as d}from"./app.21fee9ae.js";const t="/assets/request.88b02662.png",r="/assets/negotiate-caching-success.d2e35271.png",a="/assets/negotiate-caching-fail.6035dc62.png",E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"浏览器渲染机制","slug":"浏览器渲染机制","link":"#浏览器渲染机制","children":[{"level":3,"title":"渲染流程","slug":"渲染流程","link":"#渲染流程","children":[]},{"level":3,"title":"布局和回流","slug":"布局和回流","link":"#布局和回流","children":[]}]},{"level":2,"title":"浏览器缓存","slug":"浏览器缓存","link":"#浏览器缓存","children":[{"level":3,"title":"强制缓存的缓存规则","slug":"强制缓存的缓存规则","link":"#强制缓存的缓存规则","children":[]},{"level":3,"title":"协商缓存","slug":"协商缓存","link":"#协商缓存","children":[]}]},{"level":2,"title":"本地存储","slug":"本地存储","link":"#本地存储","children":[]},{"level":2,"title":"跨域","slug":"跨域","link":"#跨域","children":[{"level":3,"title":"CORS","slug":"cors","link":"#cors","children":[]}]},{"level":2,"title":"Content-Type Header","slug":"content-type-header","link":"#content-type-header","children":[]},{"level":2,"title":"Lighthouse","slug":"lighthouse","link":"#lighthouse","children":[]},{"level":2,"title":"内核、渲染引擎、js引擎","slug":"内核、渲染引擎、js引擎","link":"#内核、渲染引擎、js引擎","children":[]},{"level":2,"title":"关于app内核的讨论","slug":"关于app内核的讨论","link":"#关于app内核的讨论","children":[]},{"level":2,"title":"app自带内核和系统WebView","slug":"app自带内核和系统webview","link":"#app自带内核和系统webview","children":[]},{"level":2,"title":"小程序内核","slug":"小程序内核","link":"#小程序内核","children":[]}],"relativePath":"Topic/browser.md"}'),i={name:"Topic/browser.md"},l=d('<h2 id="浏览器渲染机制" tabindex="-1">浏览器渲染机制 <a class="header-anchor" href="#浏览器渲染机制" aria-hidden="true">#</a></h2><p><a href="https://developer.chrome.com/blog/inside-browser-part1/" target="_blank" rel="noreferrer">chrome渲染机制</a></p><h3 id="渲染流程" tabindex="-1">渲染流程 <a class="header-anchor" href="#渲染流程" aria-hidden="true">#</a></h3><ol><li><p>解析<code>html</code>文件构造<code>DOM</code>树（也叫做<code>content</code>树）</p></li><li><p>解析<code>css</code>文件，和<code>html</code>里的<code>visual instuctions</code>（应该指的是能展示的标签，即不包括<code>script</code>等）构造<code>render树</code></p><p><code>DOM</code>构造：浏览器将接收到的<code>HTML</code>代码通过<code>HTML</code>解析器解析构建成一颗<code>DOM</code>树，同时将接收到的<code>CSS</code>代码通过<code>CSS</code>解析器构建出样式表规则（<code>CSSOM</code>），然后将这些规则分别放到对应的<code>DOM</code>树节点上，得到一颗带有样式属性的<code>DOM</code>树（<code>render树</code>）</p></li><li><p><code>layout</code>（布局）：浏览器按从上到下，从左到右的顺序读取<code>DOM</code>树的<code>node</code>，然后开始获取<code>node</code>的坐标和大小等<code>css</code>属性，把每个<code>node</code>定位到对应的坐标</p></li><li><p><code>painting</code>（绘制）：遍历<code>render</code>树，用<code>UI backend layer</code>把每个<code>node</code>绘制出来</p></li></ol><h3 id="布局和回流" tabindex="-1">布局和回流 <a class="header-anchor" href="#布局和回流" aria-hidden="true">#</a></h3><p>一个意思，<code>Webkit rendering engine</code>把将元素放置在屏幕的某个位置的操作叫做<code>layout</code>，而在<code>Gecko rendering endgine</code>中叫做<code>Reflow</code>（回流）</p><h2 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-hidden="true">#</a></h2><p><img src="'+t+'" alt="图片加载失败"></p><p>强制缓存有三种情况：</p><p>不存在缓存结果和标识，则说明强制缓存失效或不存在，直接向服务器发起请求</p><p>存在缓存结果和标识，但结果失效，携带标识发起请求（协商缓存）</p><p>存在缓存结果和标识，未失效，则直接应用缓存</p><h3 id="强制缓存的缓存规则" tabindex="-1">强制缓存的缓存规则 <a class="header-anchor" href="#强制缓存的缓存规则" aria-hidden="true">#</a></h3><p>控制强制缓存的字段是响应头中的<code>Expires</code>和<code>Cache-Control</code>，后者优先级更高</p><p><code>Expires</code>：http1.0时控制缓存的字段，原理是使用客户端时间与服务端返回的时间做对比，但是客户端和服务端时间可能有误差（例如时区不同），如果客户端时间晚于服务端则资源还未过期就重新请求，反之则资源过期了客户端还在使用，在http1.1被<code>Cache-Control</code>取代</p><p><code>Cache-Control</code>取值主要为</p><ul><li>public：所有内容都被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端缓存，默认值</li><li>no-cache：客户端缓存内容，但是是协商缓存</li><li>no-store：所有内容都不缓存，每次都请求新的</li><li>max-age=xxx：缓存内容在xxx秒后失效</li></ul><p>强制缓存顺序是先内存（from memory cache）后硬盘（from disk cache），内存缓存读取速度快，进程关闭时清空</p><p>刷新时、无痕模式是内存缓存，退出重进、大型css、js文件是硬盘缓存，</p><h3 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a></h3><p><img src="'+r+'" alt="图片加载失败"></p><p><img src="'+a+'" alt="图片加载失败"></p><p>协商缓存的标识有<code>Last-Modified/If-Modified-Since</code>和<code>Etag/If-None-Match</code>，后者优先级更高</p><p><code>Last-Modified</code>：响应头字段，表示返回该资源最后被修改的时间 <code>If-Modified-Since</code>：请求头字段，服务器用来与最后被修改时间对比，一致则返回304，同意缓存，不一致则重新返回资源，状态码为200</p><p><code>Etag</code>：响应头字段，服务器对该资源的唯一标识 <code>If-None-Match</code>：请求头字段，服务器用来与自己保存的<code>Etag</code>值作对比</p><h2 id="本地存储" tabindex="-1">本地存储 <a class="header-anchor" href="#本地存储" aria-hidden="true">#</a></h2><p><code>Local Storage</code>：保存的数据没有过期时间，需要手动删除，存储空间5M</p><p><code>Session Storage</code>：保存的数据在页面关闭后会被删除，存储空间5M</p><p><code>Cookies</code>：过期时间自己设置，安全性不高，容易被拦截，存储空间4k</p><p>相同点：都是保存在客户端，且同源共享</p><p>不同点：<code>Cookies</code>数据由服务端设置，参与通信；<code>Session Storage</code>和<code>Local Storage</code>由客户端设置，不参与通信</p><p><code>Cookies</code>属性： ① <code>Domain</code>：域，表示请求的<code>url</code>符合这个格式的请求时才会带上这个<code>cookie</code> ② <code>Path</code>：路径前缀，符合这个路径的请求<code>url</code>才会带上 ③ <code>Secure</code>：为true时表示使用<code>https</code>协议才发送这个<code>cookie</code> ④ <code>HttpOnly</code>：为true时表示无法通过<code>js</code>脚本读取到这个<code>cookie</code>，防止<code>XSS</code>攻击 ⑤ <code>Expires/Max-Age</code>：过期时间</p><p>为什么有了<code>token</code>还需要<code>cookie</code>：例如通过<code>&lt;a&gt;</code>标签或<code>location.href</code>来下载文件，<code>HTTP</code>请求是浏览器发送的而不是<code>JS</code>，除了使用<code>XMLHttpRequest</code>和<code>fetch</code>发出的请求之外，页面无法自定义<code>HTTP</code>请求头&quot;Authorization&quot;来发送<code>token</code>，而用<code>url</code>发送<code>token</code>不安全，<code>token</code>暴露在<code>url</code>，会记录在浏览器历史记录、访问日志等，因此需要<code>cookie</code></p><h2 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-hidden="true">#</a></h2><h3 id="cors" tabindex="-1">CORS <a class="header-anchor" href="#cors" aria-hidden="true">#</a></h3><p>CORS（Cross-Origin Resource Sharing）：跨域资源共享，是一种支持来自其它源，访问资源的安全请求以及数据传输的机制，CORS 的发明是为了扩展和增加同源策略Same Origin Policy (SOP) 的灵活性</p><p>更具体地说，CORS 是 Web 服务器说“接受来自此来源的跨域请求”或“不接受来自此来源的跨域请求”的一种方式</p><p>例如<code>example.com</code>使用托管在<code>fonts.com</code>上的文本字体。当访问<code>example.com</code>时，用户的浏览器会请求<code>fonts.com</code>的字体。因为<code>fonts.com</code>和<code>example.com</code>是两个不同的源，所以这是一个跨域请求。如果<code>fonts.com</code>允许跨源资源共享到<code>example.com</code>，那么浏览器将继续加载字体。否则，浏览器将取消请求</p><p>参考资料：<a href="https://supertokens.com/blog/what-is-cross-origin-resource-sharing" target="_blank" rel="noreferrer">https://supertokens.com/blog/what-is-cross-origin-resource-sharing</a></p><h2 id="content-type-header" tabindex="-1">Content-Type Header <a class="header-anchor" href="#content-type-header" aria-hidden="true">#</a></h2><p><code>application/x-www-form-urlencoded</code>：格式是<code>Name=John+Smith&amp;Age=23</code>，告诉服务器自己会对查询参数进行<code>url</code>编码</p><p><code>application/json</code>：格式是<code>{ &quot;Name&quot;: &quot;John Smith&quot;, &quot;Age&quot;: 23 }</code>，它的出现是因为<code>x-www-form-urlencoded</code>对嵌套对象和数组的编码很麻烦，<code>json</code>支持嵌套结构以及更丰富的数据类型</p><p><code>multipart/form-data</code>：常用于提交那些包含文件、非ASCII数据、二进制数据的表单，它的出现是由于<code>x-www-form-urlencoded</code>对于发送大量二进制数据或包含非ASCII字符的文本时效率过低</p><p>用法：一般get请求用<code>x-www-form-urlencoded</code>，post请求用<code>json</code>，涉及到二进制数据例如上传文件时用<code>form-data</code>，不绝对，<code>x-www-form-urlencoded</code>格式用qs等序列化工具库传嵌套对象或数组也可以，也可以上传文件</p><p>简单请求<code>simple request</code>：不会触发预检<code>preflight check</code>，只允许<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>这三种<code>Content-Type</code></p><p>预检请求<code>preflight request</code>：浏览器发送正式请求前会自动发送OPTIONS请求，检查是否安全，安全才会发送实际请求，<code>application/json</code>是预检请求允许的<code>Content-Type</code>中的一种</p><p><code>x-www-form-urlencoded</code>为什么传二进制效率低：<code>x-www-form-urlencoded</code>对每个非字母数字字符<code>non-alphanumeric characters</code>（例如逗号加号等符号），都要用&#39;%HH&#39;这种一个百分号加两个表示字符的<code>ASCII</code>码的十六进制数去表示它，这就意味着对每一个字节的非字母数字字符，都要用三个字节去表示它，因此对于大型的二进制文件，效率很低</p><p>参考资料：<a href="https://stackoverflow.com/questions/9870523/what-are-the-differences-between-application-json-and-application-x-www-form-url" target="_blank" rel="noreferrer">https://stackoverflow.com/questions/9870523/what-are-the-differences-between-application-json-and-application-x-www-form-url</a></p><p>参考资料：<a href="https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data" target="_blank" rel="noreferrer">https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data</a></p><p>参考资料：<a href="https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4" target="_blank" rel="noreferrer">https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4</a></p><h2 id="lighthouse" tabindex="-1">Lighthouse <a class="header-anchor" href="#lighthouse" aria-hidden="true">#</a></h2><p>教程：<a href="https://developer.chrome.com/docs/devtools/lighthouse/" target="_blank" rel="noreferrer">https://developer.chrome.com/docs/devtools/lighthouse/</a></p><p>Chrome扩展程序容易干扰，官方建议从隐私模式（无痕模式）打开</p><p>几个性能指标</p><ul><li>First Contentful Paint：内容第一次绘制到屏幕上的时间</li><li>Time To Interactive：页面已可以处理用户交互的世界</li><li>Speed Index：加载速度</li><li>Total Blocking Time：页面被用户输入所阻塞的总时间</li><li>Largest Contentful Paint：测量最大的内容元素何时呈现到屏幕上</li><li>Cumulative Layout Shift：累积布局偏移，现有元素的位置改变才叫布局偏移，添加元素到DOM或修改现有元素大小不算，前提是元素的大小变更不会导致其他元素的位置发生改变</li></ul><p>怎么查看有没有压缩：打开Network，打开Network settings，勾选Use large request rows，在每个请求的Size中会标有两个值，上面的值是下载资源的大小，下面的值是资源原本大小，如果相同则说明没进行压缩，响应头也会有一个Content-Encoding属性，通常值为gzip、deflate或br</p><p>排除阻塞渲染的资源（Eliminate render-blocking resources）：测试资源是否影响加载，More tools =&gt; Coverage选项卡 =&gt; 点击reload图标，可以看到未使用的部分占比多少，再切到Network request blocking选项卡，添加*/xxx.js，刷新页面，浏览器会自动拦截该资源的请求，如果页面正常加载并且可交互，说明不需要该资源</p><p>断点调试：路径是Sources =&gt; File Navigator =&gt; Page，&quot;域名加端口&quot;的文件名是打包后的，找到文件名与项目名相同的，里面的ts或tsx文件是没打包之前的，在那里面打断点。Scope可以查看当前变量的值，Watch可以插入表达式执行，表达式中可以访问到变量</p><h2 id="内核、渲染引擎、js引擎" tabindex="-1">内核、渲染引擎、js引擎 <a class="header-anchor" href="#内核、渲染引擎、js引擎" aria-hidden="true">#</a></h2><p>内核包括渲染引擎、<code>js</code>引擎和其它组件，虽然我们现在习惯单独称呼<code>js</code>引擎，但在内核架构图里，<code>js</code>引擎始终是包含在内核里的，只不过可以单独拎出来，因为它和内核之间不是集成关系，而是调用关系，所以如果魔改内核的话可以替换成其它<code>js</code>引擎</p><h2 id="关于app内核的讨论" tabindex="-1">关于app内核的讨论 <a class="header-anchor" href="#关于app内核的讨论" aria-hidden="true">#</a></h2><p>app自带内核的好处：当初微信团队是主动找到X5内核的。原因是安全和可控。安全的原因是如果微信使用系统内核，一旦爆出安卓、chromium的漏洞，将非常被动。很难甚至无法修复。而且如果不是X5统一了标准（虽然之前落后了点），你们要所有机型一个个的适配，甚至包括安卓4.4以前的<code>webview</code>。这个工作量远比适配X5高N倍</p><p>知乎有条回答：微信6.1版本以上的android用户，都是使用的QQ浏览器的X5内核。5.4-6.1之间的版本，若用户安装了QQ浏览器就是使用的X5内核，若用户未安装浏览器，使用的是系统内核。系统没有qq浏览器就用系统的浏览器，有 qq 浏览器会用 qq 浏览器的内核（但评论里也有人反馈高版本微信依然使用的是系统内核的情况）</p><p>还有人回答：在高版本的安卓系统上新版本的微信，之前看过好像也是基于WebView的（当时是看的安卓10）。x5现在只用在兼容低版本系统这个场景</p><p>自测手机系统android system webview版本是87，自带浏览器打开<a href="https://ie.icoa.cn/%E7%BD%91%E7%AB%99%E6%A3%80%E6%B5%8B%E6%98%AF89%EF%BC%8C%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%98%AF86%EF%BC%8C%E8%AF%B4%E6%98%8E%E8%87%AA%E5%B8%A6%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E5%BE%AE%E4%BF%A1%E9%83%BD%E6%98%AF%E7%94%A8%E5%AE%83%E4%BB%ACapp%E8%87%AA%E5%B8%A6%E7%9A%84%E5%86%85%E6%A0%B8" target="_blank" rel="noreferrer">https://ie.icoa.cn/网站检测是89，微信浏览器打开是86，说明自带浏览器和微信都是用它们app自带的内核</a></p><p>还有一种检测办法，打开<a href="http://soft.imtt.qq.com/browser/tes/feedback.html%EF%BC%8C%E6%98%BE%E7%A4%BA000000%E8%A1%A8%E7%A4%BA%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%98%AF%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%A4%A7%E4%BA%8E0%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E5%8A%A0%E8%BD%BD%E4%BA%86x5%E5%86%85%E6%A0%B8%EF%BC%88%E6%95%B0%E5%AD%97%E6%98%AFx5%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC%E5%8F%B7%EF%BC%89" target="_blank" rel="noreferrer">http://soft.imtt.qq.com/browser/tes/feedback.html，显示000000表示加载的是系统内核，显示大于0的数字表示加载了x5内核（数字是x5内核版本号）</a></p><h2 id="app自带内核和系统webview" tabindex="-1">app自带内核和系统WebView <a class="header-anchor" href="#app自带内核和系统webview" aria-hidden="true">#</a></h2><p>遇到过一个问题：遇到一个跑在企微端的H5项目在Android 9手机上白屏，app版本已经是最新，排查半天是系统内置<code>WebView</code>版本过低，只有68，升级系统<code>WebView</code>后才解决</p><p>原因：企微自带了x5内核，可能是默认禁用掉了app自带内核才会调用系统内置<code>Webview</code>来进行渲染加载（google play商店版本的微信默认就是使用系统<code>WebView</code>内核，这也是很多人觉得觉得 Play 商店版本的微信体验会比国内版本的微信好的原因之一）</p><p>X5 WebView 内核是在APP 第一次初始化时，动态下载到APP 的内部存储空间，因为TBS SDK(Android x5 webview)采用了后台动态下发内核的方案。由于Google Play 禁止任何二进制代码的下发（包括so、dex、jar）和插件化技术的使用，故使用X5 内核的app不支持在海外Google Play上架新版本微信已经从x5内核切换到xweb内核，可以通过<code>Navigator.userAgent.toLowerCase().includes(&#39;xweb&#39;)换成xweb</code>，旧版X5内核是<code>includes(&#39;tbs&#39;)</code></p><p>组里也有人说现在企微自带的x5内核是直接在系统自带<code>WebView</code>简单封装了一下（为了减小app体积），运行的时候是调用系统<code>WebView</code>在渲染执行，所以系统<code>WebView</code>版本低会导致白屏（此条存疑）</p><h2 id="小程序内核" tabindex="-1">小程序内核 <a class="header-anchor" href="#小程序内核" aria-hidden="true">#</a></h2><p>小程序内核其实就是微信内置的内核，安卓端的还是X5内核，它是基于chromium（blink和v8）的腾讯魔改版，小程序官网不写x5，写的是chromium</p>',73),n=[l];function p(s,h,u,m,g,w){return c(),o("div",null,n)}const A=e(i,[["render",p]]);export{E as __pageData,A as default};
