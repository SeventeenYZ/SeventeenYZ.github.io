import{_ as s,c as a,o as l,a as n}from"./app.48e14931.js";const C=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"封装hook","slug":"封装hook","link":"#封装hook","children":[]},{"level":2,"title":"reactive和ref","slug":"reactive和ref","link":"#reactive和ref","children":[]},{"level":2,"title":"watch和computed","slug":"watch和computed","link":"#watch和computed","children":[]},{"level":2,"title":"表单输入绑定","slug":"表单输入绑定","link":"#表单输入绑定","children":[]},{"level":2,"title":"Prop","slug":"prop","link":"#prop","children":[{"level":3,"title":"传递一个数字或表达式时","slug":"传递一个数字或表达式时","link":"#传递一个数字或表达式时","children":[]},{"level":3,"title":"传递一个对象","slug":"传递一个对象","link":"#传递一个对象","children":[]},{"level":3,"title":"单向数据流","slug":"单向数据流","link":"#单向数据流","children":[]},{"level":3,"title":"非Prop的属性","slug":"非prop的属性","link":"#非prop的属性","children":[]}]},{"level":2,"title":"自定义事件","slug":"自定义事件","link":"#自定义事件","children":[]},{"level":2,"title":"插槽","slug":"插槽","link":"#插槽","children":[]},{"level":2,"title":"动态组件 & 异步组件","slug":"动态组件-异步组件","link":"#动态组件-异步组件","children":[]},{"level":2,"title":"处理边界情况","slug":"处理边界情况","link":"#处理边界情况","children":[{"level":3,"title":"访问子组件实例或子元素","slug":"访问子组件实例或子元素","link":"#访问子组件实例或子元素","children":[]}]},{"level":2,"title":"服务端渲染","slug":"服务端渲染","link":"#服务端渲染","children":[]}],"relativePath":"Vue/Vue.md"}'),p={name:"Vue/Vue.md"},o=n(`<p><a href="https://staging.vuejs.org" target="_blank" rel="noreferrer">官网</a></p><h2 id="封装hook" tabindex="-1">封装hook <a class="header-anchor" href="#封装hook" aria-hidden="true">#</a></h2><p>封装的hook<code>useXXX.ts</code>本质是将页面的可复用逻辑提取出来，通过一个函数调用得到它里面声明的变量和函数，逻辑跟铺开直接写在页面并无二致</p><h2 id="reactive和ref" tabindex="-1">reactive和ref <a class="header-anchor" href="#reactive和ref" aria-hidden="true">#</a></h2><p><a href="https://stackoverflow.com/questions/61452458/ref-vs-reactive-in-vue-3" target="_blank" rel="noreferrer">讨论</a></p><p>reactive：</p><p>① 仅可创建对象类型（对象、数组、Map、Set），普通类型无效</p><p>② 解构后会失去响应性（应该是仅限于属性是普通类型的情况），因为响应式要保持引用是相同的</p><p>ref：</p><p>可定义任意类型，通过<code>.value</code>调用，解构不会失去响应性</p><p>最大的区别：ref支持重新赋值，当数组指针会发生变化（即变量指向另一个数组），应该使用ref</p><p>其它情况下ref和reactive初始化值为对象时，ref底层使用reactive，会有额外的包装对象，这会带来额外开销，应优先选择reactive</p><h2 id="watch和computed" tabindex="-1">watch和computed <a class="header-anchor" href="#watch和computed" aria-hidden="true">#</a></h2><p><code>watch</code>：一个数据影响多个数据，一般这个值不需要用到它，而是要用到受它影响的其它数据</p><p>watch使用限制，具体看文档：</p><p>① 不可直接侦听响应式对象的属性值，而应用getter函数代替</p><p>② 深层侦听</p><p><code>computed</code>：一个数据受多个数据（依赖）影响，一般会用到它，依赖变更时才重新计算，不会产生副作用，有异步请求或更改DOM的操作应放在watch</p><p><code>watchEffect</code>：watch是懒执行，仅当依赖变化才执行，watchEffect是初始时也会执行，并且自动收集依赖</p><p>watchEffect和onMounted的调用时机：watchEffect是在前面，初始化时能访问数据但不能访问dom，类似于vue2的created调用时机</p><h2 id="表单输入绑定" tabindex="-1">表单输入绑定 <a class="header-anchor" href="#表单输入绑定" aria-hidden="true">#</a></h2><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">input</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">v-model</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">searchText</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">/&gt;</span><span style="color:#A6ACCD;"> // 等同于</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">input</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">searchText</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">input</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#82AAFF;">$emit</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">input</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> $event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">/&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">custom-input</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">v-model</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">searchText</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">/&gt;</span><span style="color:#A6ACCD;"> // 等同于</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">custom-input</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">searchText</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">input</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">searchText</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">$event</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">/&gt;</span></span>
<span class="line"></span></code></pre></div><p>自定义组件的<code>v-model</code>默认绑定的是<code>value</code>值和<code>input</code>事件，如果要修改则在<code>model</code>选型里定义</p><h2 id="prop" tabindex="-1">Prop <a class="header-anchor" href="#prop" aria-hidden="true">#</a></h2><h3 id="传递一个数字或表达式时" tabindex="-1">传递一个数字或表达式时 <a class="header-anchor" href="#传递一个数字或表达式时" aria-hidden="true">#</a></h3><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">blog-post</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">like</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">42</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">blog-post</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> // 会被解析成字符串&quot;42&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">blog-post</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">v-bind</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">like</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F78C6C;">42</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">blog-post</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> // 加了v-bind才能被解析成数字&quot;42&quot;，表达式同理</span></span>
<span class="line"></span></code></pre></div><h3 id="传递一个对象" tabindex="-1">传递一个对象 <a class="header-anchor" href="#传递一个对象" aria-hidden="true">#</a></h3><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">blog-post</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">v-bind</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">post</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">blog-post</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> // 等价于</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">blog-post</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">v-bind</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">post</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">id</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">v-bind</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">title</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">post</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">title</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">blog-post</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><h3 id="单向数据流" tabindex="-1">单向数据流 <a class="header-anchor" href="#单向数据流" aria-hidden="true">#</a></h3><p>当子组件试图修改props里的值时，控制台会发出警告</p><p>解决办法：子组件定义一个变量或计算属性（需要对初始值进行转化时）来接受props的值</p><p>注：如果props传递的是对象或数组等引用值则不适用</p><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">props: [&#39;initialCounter&#39;],</span></span>
<span class="line"><span style="color:#A6ACCD;">data: function () {</span></span>
<span class="line"><span style="color:#A6ACCD;">  return {</span></span>
<span class="line"><span style="color:#A6ACCD;">    counter: this.initialCounter</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="非prop的属性" tabindex="-1">非Prop的属性 <a class="header-anchor" href="#非prop的属性" aria-hidden="true">#</a></h3><p>非Prop属性包含<code>class</code>、<code>id</code>和<code>style</code>等属性以及<code>emit</code>事件，默认作用到子组件的根组件上</p><p><code>$attrs</code>接收父组件传来的除了<code>class</code>、<code>id</code>和<code>style</code>之外的非<code>Prop</code>属性，可用在多个标签上（不过一般没啥用）</p><p><code>$listeners</code>接收除了原生事件（即不含<code>.native</code>修饰符）之外的事件</p><p>如果要指定非<code>Prop</code>属性作用到某个标签上</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">Vue.component(&#39;base-input&#39;, {</span></span>
<span class="line"><span style="color:#A6ACCD;">    inheritAttrs: false,</span></span>
<span class="line"><span style="color:#A6ACCD;">    props: [&#39;title&#39;, &#39;value&#39;],</span></span>
<span class="line"><span style="color:#A6ACCD;">    template: \`</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">header</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">...</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">header</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">main</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">v-bind</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">$attrs</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">...</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">main</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> // 父组件传来的非Prop属性会作用到它身上</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">footer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">...</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">footer</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      \`</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"></span></code></pre></div><h2 id="自定义事件" tabindex="-1">自定义事件 <a class="header-anchor" href="#自定义事件" aria-hidden="true">#</a></h2><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">text-document</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">title</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">title</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">update</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">title</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">title </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> $event</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">/&gt; // 等同于</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;text-document :title.sync=&quot;title&quot;&gt;</span></span>
<span class="line"></span></code></pre></div><p>和<code>v-model</code>区别，因为<code>v-model</code>只能有一个，所以多了<code>v-bind.sync</code>用来绑定其它需要双向绑定的值（<code>Vue3</code>里合并了）</p><h2 id="插槽" tabindex="-1">插槽 <a class="header-anchor" href="#插槽" aria-hidden="true">#</a></h2><p>① 公共组件提供插槽并设置默认内容</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">v-if</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">propContent</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;slot name=&quot;prepend&quot;&gt;{{ propContent }}&lt;/slot&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> // 缺点：传的值不能是falsy值</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">v-if</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">$slots</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prepend</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;slot name=&quot;prepend&quot;&gt;{{ propContent }}&lt;/slot&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>② 跨组件传slot</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 祖组件（页面组件等）</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">#</span><span style="color:#C792EA;">label</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">	代理性质sada</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">// 父组件（公共组件等）</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">slot</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">#</span><span style="color:#C792EA;">label</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">label</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">// 在用element-ui的时候 要用旧语法匹配组件提供的插槽名</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">slot</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">slot</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">label</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">label</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">// 孙组件</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">slot</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">label</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">{{ label }}</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><h2 id="动态组件-异步组件" tabindex="-1">动态组件 &amp; 异步组件 <a class="header-anchor" href="#动态组件-异步组件" aria-hidden="true">#</a></h2><p><code>keep-alive</code>的<code>exclude</code>属性包含的组件，不会调用<code>activated</code>和<code>deactivated</code>这两个钩子函数</p><p><code>created</code>和<code>activated</code>调用后台数据的区别 <code>created</code>只调用一次，<code>activated</code>每次进入都调用</p><p>注意点：keep-alive的exclude包含的组件名，要和.vue文件的name的文件名大小写一致，不然可能缓存不了</p><h2 id="处理边界情况" tabindex="-1">处理边界情况 <a class="header-anchor" href="#处理边界情况" aria-hidden="true">#</a></h2><h3 id="访问子组件实例或子元素" tabindex="-1">访问子组件实例或子元素 <a class="header-anchor" href="#访问子组件实例或子元素" aria-hidden="true">#</a></h3><p><code>this.$refs</code>可能是<code>undefined</code>，因为<code>$refs</code>只在组件渲染完成后生效，需要包在<code>nextTick</code>里</p><p>在<code>v-for</code>使用<code>ref</code>，索引可能不准</p><h2 id="服务端渲染" tabindex="-1">服务端渲染 <a class="header-anchor" href="#服务端渲染" aria-hidden="true">#</a></h2><p>如果我们只是想显示一堆不变的数据，那么我们直接写一个a.html丢到服务器上让客户端访问就可以了。但这是基本不可能的事情，数据一般是变化的。你不可能为每套数据写一个视图，所以我们需要分离数据和视图，然后使用一种技术将数据塞到视图中，这种技术就叫渲染。这工作放在服务器上做就是服务器渲染，放在浏览器做就是浏览器渲染。</p><p>这里的渲染，就是指生成html文档的过程，和浏览器渲染html没有关系。 浏览器端渲染，指的是用js去生成html，前端做路由，举例：React、Vue等前端框架，适合单页面应用程序。服务器端渲染，指的是用后台语言通过一些模版引擎生成html。举例：PHP文件、JSP文件、Python的Flask配合Jinja引擎、Django框架、Java配合vm模版引擎、NodeJS配合Jade，适合多页面应用。 所以有时为了让单页面应用利于SEO，让服务器和客户端同构，也使用React/Vue渲染的方案</p><p>浏览器渲染：单页应用用的基本都是浏览器渲染。优点很明确，后端只提供数据，前端做视图和交互逻辑，分工明确。服务器只提供接口，路由以及渲染都丢给前端，服务器计算压力变轻了。但是弱点就是用户等待时间变长了，尤其在请求数多而且有一定先后顺序的时候。</p><p>服务器渲染：服务器接到用户请求之后，计算出用户需要的数据，然后将数据更新成视图（也就是一串dom字符）发给客户端，客户端直接将这串字符塞进页面即可。这样做的好处是响应很快，用户体验会比较好，另外对于搜索引擎来说也是友好的，有SEO优化。</p><p>客户端渲染路线：1. 请求一个html -&gt; 2. 服务端返回一个html -&gt; 3. 浏览器下载html里面的js/css文件 -&gt; 4. 等待js文件下载完成 -&gt; 5. 等待js加载并初始化完成 -&gt; 6. js代码终于可以运行，由js代码向后端请求数据( ajax/fetch ) -&gt; 7. 等待后端数据返回 -&gt; 8. 客户端从无到完整地，把数据渲染为响应页面</p><p>服务端渲染路线：2. 请求一个html -&gt; 2. 服务端请求数据( 内网请求快 ) -&gt; 3. 服务器初始渲染（服务端性能好，较快） -&gt; 4. 服务端返回已经有正确内容的页面 -&gt; 5. 客户端请求js/css文件 -&gt; 6. 等待js文件下载完成 -&gt; 7. 等待js加载并初始化完成 -&gt; 8. 客户端把剩下一部分渲染完成( 内容小，渲染快 )</p><p>对同一个组件，服务端渲染“可视的”一部分( render/componentWillMount部分代码 )，为确保组件有完善的生命周期及事件处理，客户端需要再次渲染。即：服务端渲染，实际上也是需要客户端做开销很小的二次渲染。</p><p>根据以上特点，在用户体验要求比较高的页面（首屏）、重复较多的公共页面可以考虑使用服务器渲染，减少ajax请求和提升用户体验。</p><p>比较：</p><ol><li>数据请求：由服务端请求数据而不是客户端请求数据，这是“快”的一个主要原因。服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差（主要原因）。</li><li>步骤：服务端是先请求数据然后渲染“可视”部分，而客户端是等待js代码下载、加载完成再请求数据、渲染。即：服务端渲染不用等待js代码下载完成再请求数据，并会返回一个已经有内容的页面。</li><li>渲染性能：服务端性能比客户端高，渲染速度快</li><li>渲染内容：服务端渲染会把”可视“部分先渲染，然后交给客户端再作部分渲染。而客户端渲染，则是从无到有，需要经历完整的渲染步骤。</li></ol>`,66),e=[o];function t(c,r,D,i,F,y){return l(),a("div",null,e)}const A=s(p,[["render",t]]);export{C as __pageData,A as default};
