import{_ as o,c as e,o as s,a as n}from"./app.b1167376.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"Cookie + Session登录","slug":"cookie-session登录","link":"#cookie-session登录","children":[]},{"level":2,"title":"token登录","slug":"token登录","link":"#token登录","children":[]},{"level":2,"title":"token续签","slug":"token续签","link":"#token续签","children":[{"level":3,"title":"有了token为什么还要cookie","slug":"有了token为什么还要cookie","link":"#有了token为什么还要cookie","children":[]}]},{"level":2,"title":"JWT","slug":"jwt","link":"#jwt","children":[]}],"relativePath":"Tool/login.md"}'),c={name:"Tool/login.md"},a=n(`<h2 id="cookie-session登录" tabindex="-1">Cookie + Session登录 <a class="header-anchor" href="#cookie-session登录" aria-hidden="true">#</a></h2><p><code>http</code>是无状态协议，客户端发起请求时与服务器建立连接，请求完成后又会断开连接，这种方式是为了节省传输时占用的连接资源，为了判断客户端的登录状态推出了<code>Cookie</code></p><p><code>Cookie</code>是服务器给客户端的一段特殊信息，客户端每次发送请求时会在请求头带上这些特殊信息</p><p>服务器对<code>Cookie</code>进行认证，需要通过<code>Session</code></p><p><code>Session</code>是一种记录客户端状态的机制，服务器在验证登录成功后，会创建<code>SessionId</code>并保存起来，并通过<code>set-cookie</code>将<code>SessionId</code>写入<code>Cookie</code>中，当客户端再次访问的时候比对<code>Cookie</code>中的<code>SessionId</code>与服务端保存的<code>SessionId</code>是否一致来验证</p><p>存在的问题：</p><p>服务端对接大量的客户端也就需要保存大量的<code>SessionId</code> 如果服务端是集群，为了同步登录态，需要将<code>SessionId</code>同步到每一台机器上</p><h2 id="token登录" tabindex="-1">token登录 <a class="header-anchor" href="#token登录" aria-hidden="true">#</a></h2><p><code>token</code>是服务端生成的一串字符串当成客户端请求的一个标识，首次登录后，服务端生成一个<code>token</code>返回给客户端，客户端自行保存，后续访问带上这个<code>token</code>来让服务器验证身份，用解析<code>token</code>的计算时间换取<code>session</code>的存储空间</p><h2 id="token续签" tabindex="-1">token续签 <a class="header-anchor" href="#token续签" aria-hidden="true">#</a></h2><p>通过双<code>token</code>，即<code>access token</code>和<code>refresh token</code>来实现<code>token</code>续签（<code>refresh token</code>也有的叫<code>cache token</code>）</p><p>后端为了<code>token</code>的安全性，一般会把<code>token</code>的过期时间设置得比较短，而为了避免用户频繁登录，传给客户端保存的是<code>access token</code>，当验证<code>access token</code>有效时，会根据规则取出<code>refresh token</code>判断是否存在</p><p>不存在则说明客户空闲过久，信息失效需要重新登录。存在则验证是否过期，过期会重新续签<code>token</code></p><p>例如<code>access token</code>有效期12小时，<code>refresh token</code>有效期24小时，用户如果在超过12小时但是不到24小时的时间内请求服务器则会续签<code>token</code>，超过24小时就需要重新登录</p><h3 id="有了token为什么还要cookie" tabindex="-1">有了token为什么还要cookie <a class="header-anchor" href="#有了token为什么还要cookie" aria-hidden="true">#</a></h3><p>例如token是在axios请求拦截里添加请求头Authorization：{token}，当通过location.href =&#39;文件地址&#39;下载文件，默认发起一个get请求，但是不会经过axios请求拦截器（该请求也会自动带上cookie），因此无法添加token，需要cookie以便能实现认证下载，类似的还有通过a标签下载</p><p>不用cookie解决办法：不用cookie会比较麻烦，如果要用ajax去接收，类型改成blob，然后去下载这个资源或者后端配合，从header中获取不到就从query string(params)获取前端url带上token参数 download?token={token}</p><h2 id="jwt" tabindex="-1">JWT <a class="header-anchor" href="#jwt" aria-hidden="true">#</a></h2><p><code>JSON Web Token</code>（JWT）是一个<code>token</code>的具体实现方式，是目前最流行的跨域认证解决方案</p><p>原理：服务器认证以后，生成一个<code>JSON</code>对象然后转变成一个字符串即<code>token</code>，返回给用户，如</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">姓名</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">张三</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">角色</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">普通用户</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">到期时间</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">2023年2月11日0点0分</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div>`,21),t=[a];function l(d,p,i,r,k,h){return s(),e("div",null,t)}const y=o(c,[["render",l]]);export{F as __pageData,y as default};
