import{_ as s,c as a,o as n,a as e}from"./app.f98d1513.js";const C=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"Core Loop","slug":"core-loop","link":"#core-loop","children":[{"level":3,"title":"关于prop的重渲染","slug":"关于prop的重渲染","link":"#关于prop的重渲染","children":[]},{"level":3,"title":"纯静态组件的重渲染","slug":"纯静态组件的重渲染","link":"#纯静态组件的重渲染","children":[]},{"level":3,"title":"re-render和diff的区别","slug":"re-render和diff的区别","link":"#re-render和diff的区别","children":[]}]},{"level":2,"title":"React的重渲染","slug":"react的重渲染","link":"#react的重渲染","children":[]},{"level":2,"title":"useMemo and useCallback","slug":"usememo-and-usecallback","link":"#usememo-and-usecallback","children":[{"level":3,"title":"声明计算属性","slug":"声明计算属性","link":"#声明计算属性","children":[]}]},{"level":2,"title":"useCallback","slug":"usecallback","link":"#usecallback","children":[{"level":3,"title":"为什么不所有函数都用useCallback包裹","slug":"为什么不所有函数都用usecallback包裹","link":"#为什么不所有函数都用usecallback包裹","children":[]}]},{"level":2,"title":"useMemo","slug":"usememo","link":"#usememo","children":[]},{"level":2,"title":"useContext","slug":"usecontext","link":"#usecontext","children":[]},{"level":2,"title":"useRef","slug":"useref","link":"#useref","children":[]},{"level":2,"title":"useEvent","slug":"useevent","link":"#useevent","children":[]},{"level":2,"title":"useEffect","slug":"useeffect","link":"#useeffect","children":[]},{"level":2,"title":"Fragment (<>...</>)","slug":"fragment","link":"#fragment","children":[]}],"relativePath":"Framework/React.md"}'),o={name:"Framework/React.md"},l=e(`<p><a href="https://beta.reactjs.org" target="_blank" rel="noreferrer">官网</a></p><h2 id="core-loop" tabindex="-1">Core Loop <a class="header-anchor" href="#core-loop" aria-hidden="true">#</a></h2><p>阅读资料：<a href="https://www.joshwcomeau.com/react/why-react-re-renders/" target="_blank" rel="noreferrer">https://www.joshwcomeau.com/react/why-react-re-renders/</a></p><p>React也是状态驱动视图的思想，保持state与UI的同步</p><p>React的每次重渲染都是因为state的改变，这是唯一触发重渲染的条件（prop和context的改变不是触发重渲染的因素）</p><p>React每次渲染都是一个快照，展示基于当前state的UI，state改变了，React UI通过重新渲染来修改，创建了一个新的快照，它可以通过比较快照找出需要更改的内容</p><p>React重渲染规则：当一个组件重渲染时，它底下的所有子孙组件都会进行重渲染</p><h3 id="关于prop的重渲染" tabindex="-1">关于prop的重渲染 <a class="header-anchor" href="#关于prop的重渲染" aria-hidden="true">#</a></h3><p>当一个组件触发重渲染时，它会尝试重渲染所有子孙组件，不管传没传prop</p><p>这是React有点违反直觉的地方，如果一个触发重渲染的组件，它的子组件没有接收prop，照样也会跟着重渲染呢，哪怕它是纯静态的，原因是对于React来说，很难确定一个组件有没有直接或间接地受到state改变的影响，如果一个子组件有很多的prop但是没有太多的子孙组件，与直接重新渲染相比，检查哪些prop发生变化并针对性地去渲染会更慢</p><p>在理想状态下，React组件都是纯粹的，相同的prop返回的UI一定是相同的，然而在现实情况下，有很多组件是不纯粹的，例如</p><div class="language-tsx"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">currentTime</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">now</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Date</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    	</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">It is currently </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">now</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toString</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">    )</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>这个组件在任何时候渲染都会展示不一样的值，因为它依赖于当前时间</p><p>还有一种情况比如传递一个ref作为prop，React很难分辨需不需要进行重渲染，为了保险起见，它会选择重渲染，因为React的第一原则就是确保用户看到的UI与state保持同步，所以即便可能渲染是无意义的，它也会进行重新渲染</p><h3 id="纯静态组件的重渲染" tabindex="-1">纯静态组件的重渲染 <a class="header-anchor" href="#纯静态组件的重渲染" aria-hidden="true">#</a></h3><p>React为什么不跳过纯静态组件的重渲染：我们容易高估重渲染的成本，对于React来说，渲染纯静态组件是非常快且成本极小的</p><h3 id="re-render和diff的区别" tabindex="-1">re-render和diff的区别 <a class="header-anchor" href="#re-render和diff的区别" aria-hidden="true">#</a></h3><p>两者发生的时间节点不一样，先re-render后diff</p><p>当state改变时，当前组件和所有子孙组件触发re-render</p><p>re-render后返回的jsx即新的快照，React拿着这份新的快照去更新dom树的过程是diff</p><h2 id="react的重渲染" tabindex="-1">React的重渲染 <a class="header-anchor" href="#react的重渲染" aria-hidden="true">#</a></h2><p><code>Core Loop</code>：<code>initial render</code> =&gt; <code>React Core do something</code> =&gt; <code>next render</code> =&gt; <code>React Core do something</code> =&gt; <code>next render</code> ...</p><p>React渲染时，调用function返回的JSX就像返回一个可交互的快照（interactive snapshot），然后将快照与屏幕上的UI进行匹配，重渲染就是重新调用一次function，如此循环，渲染就是一个个基于当时<code>state</code>生成的一个快照</p><ol><li>React calls your function again.</li><li>Your function returns a new JSX snapshot.</li><li>React then updates the screen to match the snapshot you’ve returned.</li></ol><p><code>state</code>改变，排队等候新的渲染 =&gt; <code>React</code>根据新的<code>state</code>值进行重渲染</p><p><code>React Core do something</code>：两次渲染之间<code>React Core</code>会做一些操作，例如更新<code>state</code></p><p><code>state</code>虽然是声明在<code>function</code>中，但其实是<code>function</code>外部的<code>React Core</code>在管理，可以看成<code>React Core</code>有一个地方专门存储这些<code>state</code></p><p>一次渲染中，<code>state</code>是不会变的，<code>state</code>改变是通过<code>setState</code>函数去通知<code>React Core</code>，然后排队等候<code>React Core</code>做一些操作后进行新的渲染</p><p>这也可以解释官方的一些例子</p><ol><li><p>修改<code>state</code>后为什么不能立即获取新的<code>state</code>值的原因：因为此时还处在<code>initial render</code>的快照中，<code>state</code>还是旧的</p></li><li><p>为什么连续调用三次<code>setNumber(number + 1)</code>，是增加1不是增加3：此时还处在<code>initial render</code>的快照中，<code>number</code>永远都是0，相当于把<code>number</code>赋值为1这个操作重复了3次，提交给React Core的新的number值自然是1</p></li><li><p>放在<code>setTimeout</code>也获取不到新的<code>state</code>值：<code>setNumber(number + 5)</code>，紧接着<code>setTimeout(() =&gt; alert(number), 3000)</code>，不管延迟多久<code>alert</code>的永远是<code>initial render</code>里的<code>number</code>值</p></li></ol><h2 id="usememo-and-usecallback" tabindex="-1">useMemo and useCallback <a class="header-anchor" href="#usememo-and-usecallback" aria-hidden="true">#</a></h2><p>因为React的重渲染规则，出来的两个优化的hook，在重渲染时，只当依赖变化时才重新计算返回值</p><p>但作为优化的后备手段，React推荐在交互响应慢的时候，排除其它选择或可能的缺陷后才需要用到（If your interactions are fast enough, you don’t need memoization.）</p><p><code>useCallback(fn, deps)</code>相当于<code>useMemo(() =&gt; fn, deps)</code></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useCallback</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">fn</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">dependencies</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useMemo</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fn</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">dependencies</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><code>useMemo</code>：缓存一个计算结果，类似<code>Vue</code>的<code>computed</code></p><p><code>useCallback</code>：缓存一个函数定义，方便传递给子组件，让子组件跳过重渲染</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> memoValue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useMemo</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> fn</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> deps) </span><span style="color:#676E95;font-style:italic;">// 返回值memoValue一般是一个变量</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> callbackValue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useCallback</span><span style="color:#A6ACCD;">(fn</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> deps) </span><span style="color:#676E95;font-style:italic;">// 返回值callbackValue是一个函数</span></span>
<span class="line"></span></code></pre></div><p>阅读资料：<a href="https://www.joshwcomeau.com/react/usememo-and-usecallback/" target="_blank" rel="noreferrer">https://www.joshwcomeau.com/react/usememo-and-usecallback/</a></p><h3 id="声明计算属性" tabindex="-1">声明计算属性 <a class="header-anchor" href="#声明计算属性" aria-hidden="true">#</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">amount1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> setAmount1</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">amount2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> setAmount2</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> totalAmount </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useMemo</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> amount1 </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> amount2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> [amount1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> amount2]) </span><span style="color:#676E95;font-style:italic;">// 相当于vue的computed</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> totalAmount </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> amount1 </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> amount2 </span><span style="color:#676E95;font-style:italic;">// 和useMemo区别是触发渲染会重新计算</span></span>
<span class="line"></span></code></pre></div><h2 id="usecallback" tabindex="-1">useCallback <a class="header-anchor" href="#usecallback" aria-hidden="true">#</a></h2><p>在<code>class component</code>中，可以使用<code>extends PureComponent </code>，当<code>prop</code>和<code>state</code>不变时，该组件跳过重渲染，而在<code>function component</code>中，<code>useState</code>的<code>set function</code>已经默认当<code>state</code>相同时跳过重渲染，而<code>prop</code>的优化则用<code>memo</code>来实现，传递给<code>memo</code>的<code>function component</code>会在<code>prop</code>相同时会跳过重渲染</p><p><code>memo</code>的缺点：父组件中功能函数的定义不管是<code>function() {}</code>还是<code>const xxx = () =&gt; {}</code>，都是一个新函数，因此用<code>memo</code>包一层的子组件时是不会跳过重渲染的，因此需要<code>useCallback</code></p><div class="language-tsx"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">memo</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当prop相同时跳过重渲染，当prop是函数时不生效</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> ShippingForm </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">memo</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ShippingForm</span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">onSubmit</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">...</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ProductPage</span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">productId</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">referrer</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">theme</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ProductPage每次渲染时，handleSubmit都是一个新创建的函数</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">handleSubmit</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">...</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">theme</span><span style="color:#89DDFF;">}&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">{</span><span style="color:#676E95;font-style:italic;">/* 因此用memo方法的ShippingForm没办法跳过重渲染 */</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">ShippingForm</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onSubmit</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">handleSubmit</span><span style="color:#89DDFF;">} /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>除了缓存传给子组件的函数外，<code>useCallback</code>另一个有价值的地方是当前组件的其它<code>hook</code>的依赖为函数时，可以用<code>useCallback</code>缓存起来，例如</p><div class="language-tsx"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ChatRoom</span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">roomId</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">message</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">setMessage</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">createOptions</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      serverUrl</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">https://localhost:1234</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">      roomId</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">roomId</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">/* const createOptions = useCallback(() =&gt; {</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    return {</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">      serverUrl: &#39;https://localhost:1234&#39;,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">      roomId: roomId</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    };</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">  }, [roomId]); */</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 仅当roomId改变时返回新的函数</span></span>
<span class="line"><span style="color:#F07178;">    </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">useEffect</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">options</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">createOptions</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">connection</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">createConnection</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">connection</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">connect</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">connection</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">disconnect</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> [</span><span style="color:#A6ACCD;">createOptions</span><span style="color:#F07178;">])</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;"> </span><span style="color:#676E95;font-style:italic;">// 如果createOptions不用useCallback缓存起来，那么每次渲染都是新的，造成无限触发</span></span>
<span class="line"><span style="color:#89DDFF;"> </span><span style="color:#676E95;font-style:italic;">// 但是更好的写法是将createOptions定义在useEffect里，依赖项为roomId</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="为什么不所有函数都用usecallback包裹" tabindex="-1">为什么不所有函数都用useCallback包裹 <a class="header-anchor" href="#为什么不所有函数都用usecallback包裹" aria-hidden="true">#</a></h3><p><code>function component</code>中创建内部函数成本是很低的，而用了<code>useCallback</code>，每次渲染依然会创建一个新函数，只不过React会忽略它（因为依赖项没有改变）返回一个缓存过的函数，多出了计算依赖项是否改变的计算成本</p><h2 id="usememo" tabindex="-1">useMemo <a class="header-anchor" href="#usememo" aria-hidden="true">#</a></h2><p>除了在本组件中充当类似<code>Vue</code>的<code>computed</code>的作用外，<code>useMemo</code>还可以和<code>useCallback</code>一样用来跳过子组件的重渲染，传递给子组件的时候，<code>useCallback</code>返回值是函数，<code>useMemo</code>返回值一般是数组或对象</p><div class="language-tsx"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useMemo</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useCallback</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ProductPage</span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">productId</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">referrer</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">product</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useData</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/product/</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">productId</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">requirements</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useMemo</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 缓存函数调用的结果</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">computeRequirements</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">product</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> [</span><span style="color:#A6ACCD;">product</span><span style="color:#F07178;">])</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">handleSubmit</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useCallback</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">orderDetails</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 缓存函数本身</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> [</span><span style="color:#A6ACCD;">productId</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">referrer</span><span style="color:#F07178;">])</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">theme</span><span style="color:#89DDFF;">}&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">ShippingForm</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">requirements</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">requirements</span><span style="color:#89DDFF;">} </span><span style="color:#C792EA;">onSubmit</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">handleSubmit</span><span style="color:#89DDFF;">} /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>如何决定是否需要缓存计算结果：可以用<code>console.time</code>和<code>console.timeEnd</code>来判断使用<code>useMemo</code>与否的性能差，官方是推荐超过1ms时可以考虑用<code>useMemo</code></p><h2 id="usecontext" tabindex="-1">useContext <a class="header-anchor" href="#usecontext" aria-hidden="true">#</a></h2><p>通过<code>createContext</code>和<code>useContext</code>的配合使用，使得子孙组件可以接收某个上层组件传递的信息（不管隔多少层），类似于<code>Vue</code>的<code>provide</code>和<code>inject</code></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 在顶层</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> theme </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createContext</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 在底层</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> theme </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useContext</span><span style="color:#A6ACCD;">(ThemeContext)</span></span>
<span class="line"></span></code></pre></div><h2 id="useref" tabindex="-1">useRef <a class="header-anchor" href="#useref" aria-hidden="true">#</a></h2><p>保存一些和渲染无关的信息，例如DOM节点或timeout ID，修改时不会触发重渲染，当修改值不需要重新渲染时，使用<code>useRef</code>节省开销</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useRef</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// ref.current = 0</span></span>
<span class="line"></span></code></pre></div><h2 id="useevent" tabindex="-1">useEvent <a class="header-anchor" href="#useevent" aria-hidden="true">#</a></h2><p>保持对函数引用始终一样，包裹这个函数，无论prop或state改变都不会重新创建，而且这个函数可以访问最新的prop和state的最新值</p><p>参考资料：<a href="https://blog.logrocket.com/what-you-need-know-react-useevent-hook-rfc/" target="_blank" rel="noreferrer">https://blog.logrocket.com/what-you-need-know-react-useevent-hook-rfc/</a></p><h2 id="useeffect" tabindex="-1">useEffect <a class="header-anchor" href="#useeffect" aria-hidden="true">#</a></h2><p><code>useEffect</code>是为了保持与外部系统同步，例如接口数据，访问DOM等，只涉及到<code>state</code>或<code>prop</code>等不应该放在<code>useEffect</code>，因为<code>prop</code>和<code>state</code>是<code>React</code>系统里的，外部系统是指非<code>React</code>系统的部分，例如后端接口数据和第三方库，而在实际开发中需要与第三方库同步的情况极少，一般<code>useEffect</code>只用于调接口，所以简单判断是否需要用<code>useEffect</code>的条件是是否需要调接口，具体见：<a href="https://react.dev/learn/you-might-not-need-an-effect" target="_blank" rel="noreferrer">You Might Not Need an Effect</a></p><p><code>function component</code>里的执行语句，例如<code>if</code>等是在渲染过程中执行，渲染过程可以简单看成是<code>function component</code>的<code>function</code>执行过程，<code>useEffect</code>中的是每次渲染完成之后执行，也就是<code>function</code>执行之后执行，因此在<code>useEffect</code>中<code>setState</code>但忘记声明依赖会造成无限循环：渲染完成 =&gt; 执行<code>effect</code>，触发<code>setState</code> =&gt; 触发渲染 =&gt; 渲染完成 ...</p><p><code>useEffect</code>不声明依赖数组和声明空数组的区别：不声明依赖数组会每次渲染<code>render</code>都执行，声明空数组是挂载<code>mounted</code>时执行，<code>mounted</code>只会在初次渲染后触发一次，后续update不触发</p><p><code>useEffect</code>在<code>mounted</code>后和每次<code>render</code>后执行，<code>cleanup</code>函数在每次<code>render</code>前以及<code>unmonted</code>后执行，如果两次渲染中依赖项的值不变，那么<code>effect</code>函数和<code>cleanup</code>函数都会跳过，不执行 流程是<code>mounted</code> =&gt; 执行<code>effect</code> =&gt; 触发重渲染 =&gt; 执行<code>cleanup</code>函数 =&gt; 重渲染完成 =&gt; 执行<code>effect</code> =&gt; 触发重渲染 =&gt; .... =&gt; <code>unmounted</code> =&gt; 执行<code>cleanup</code>函数 =&gt; 结束，具体见：<a href="https://react.dev/learn/synchronizing-with-effects#each-render-has-its-own-effects" target="_blank" rel="noreferrer">https://react.dev/learn/synchronizing-with-effects#each-render-has-its-own-effects</a></p><p>race-conditions：<a href="https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect" target="_blank" rel="noreferrer">https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect</a></p><h2 id="fragment" tabindex="-1">Fragment (&lt;&gt;...&lt;/&gt;) <a class="header-anchor" href="#fragment" aria-hidden="true">#</a></h2><p>相当于<code>Vue</code>的<code>&lt;template&gt;</code>，<code>&lt;Fragment&gt;</code>大多数情况下等同于<code>&lt;&gt;...&lt;/&gt;</code>，区别在于渲染列表时，<code>&lt;&gt;...&lt;/&gt;</code>不能设定key而<code>&lt;Fragment&gt;</code>可以</p>`,70),p=[l];function t(c,r,y,F,d,i){return n(),a("div",null,p)}const A=s(o,[["render",t]]);export{C as __pageData,A as default};
