import{_ as s,c as a,o as e,a as n}from"./app.523b53ce.js";const D=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"Core Loop","slug":"core-loop","link":"#core-loop","children":[{"level":3,"title":"关于prop的重渲染","slug":"关于prop的重渲染","link":"#关于prop的重渲染","children":[]},{"level":3,"title":"纯静态组件的重渲染","slug":"纯静态组件的重渲染","link":"#纯静态组件的重渲染","children":[]}]},{"level":2,"title":"useMemo and useCallback","slug":"usememo-and-usecallback","link":"#usememo-and-usecallback","children":[]},{"level":2,"title":"声明计算属性","slug":"声明计算属性","link":"#声明计算属性","children":[]},{"level":2,"title":"useRef","slug":"useref","link":"#useref","children":[]},{"level":2,"title":"Fragment (<>...</>)","slug":"fragment","link":"#fragment","children":[]}],"relativePath":"Framework/React.md"}'),l={name:"Framework/React.md"},o=n(`<p><a href="https://beta.reactjs.org" target="_blank" rel="noreferrer">官网</a></p><h2 id="core-loop" tabindex="-1">Core Loop <a class="header-anchor" href="#core-loop" aria-hidden="true">#</a></h2><p>阅读资料：<a href="https://www.joshwcomeau.com/react/why-react-re-renders/" target="_blank" rel="noreferrer">https://www.joshwcomeau.com/react/why-react-re-renders/</a></p><p>React也是状态驱动视图的思想，保持state与UI的同步</p><p>React的每次重渲染都是因为state的改变，这是唯一触发重渲染的条件（prop和context的改变不是触发重渲染的因素）</p><p>React每次渲染都是一个快照，展示基于当前state的UI，state改变了，React UI通过重新渲染来修改，创建了一个新的快照，它可以通过比较快照找出需要更改的内容</p><p>React重渲染规则：当一个组件重渲染时，它底下的所有子孙组件都会进行重渲染</p><h3 id="关于prop的重渲染" tabindex="-1">关于prop的重渲染 <a class="header-anchor" href="#关于prop的重渲染" aria-hidden="true">#</a></h3><p>当一个组件触发重渲染时，它会尝试重渲染所有子孙组件，不管传没传prop</p><p>这是React有点违反直觉的地方，如果一个触发重渲染的组件，它的子组件没有接收prop，照样也会跟着重渲染呢，哪怕它是纯静态的，原因是对于React来说，很难确定一个组件有没有直接或间接地受到state改变的影响，如果一个子组件有很多的prop但是没有太多的子孙组件，与直接重新渲染相比，检查哪些prop发生变化并针对性地去渲染会更慢</p><p>在理想状态下，React组件都是纯粹的，相同的prop返回的UI一定是相同的，然而在现实情况下，有很多组件是不纯粹的，例如</p><div class="language-tsx"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">currentTime</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">now</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Date</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    	</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">It is currently </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">now</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toString</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">    )</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>这个组件在任何时候渲染都会展示不一样的值，因为它依赖于当前时间</p><p>还有一种情况比如传递一个ref作为prop，React很难分辨需不需要进行重渲染，为了保险起见，它会选择重渲染，因为React的第一原则就是确保用户看到的UI与state保持同步，所以即便可能渲染是无意义的，它也会进行重新渲染</p><h3 id="纯静态组件的重渲染" tabindex="-1">纯静态组件的重渲染 <a class="header-anchor" href="#纯静态组件的重渲染" aria-hidden="true">#</a></h3><p>React为什么不跳过纯静态组件的重渲染：我们容易高估重渲染的成本，对于React来说，渲染纯静态组件是非常快且成本极小的</p><h2 id="usememo-and-usecallback" tabindex="-1">useMemo and useCallback <a class="header-anchor" href="#usememo-and-usecallback" aria-hidden="true">#</a></h2><p>阅读资料：<a href="https://www.joshwcomeau.com/react/usememo-and-usecallback/" target="_blank" rel="noreferrer">https://www.joshwcomeau.com/react/usememo-and-usecallback/</a></p><h2 id="声明计算属性" tabindex="-1">声明计算属性 <a class="header-anchor" href="#声明计算属性" aria-hidden="true">#</a></h2><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">amount1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> setAmount1</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">amount2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> setAmount2</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> totalAmount </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useMemo</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> amount1 </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> amount2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> [amount1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> amount2]) </span><span style="color:#676E95;font-style:italic;">// 相当于vue的computed</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> totalAmount </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> amount1 </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> amount2 </span><span style="color:#676E95;font-style:italic;">// 和useMemo区别是触发渲染会重新计算</span></span>
<span class="line"></span></code></pre></div><h2 id="useref" tabindex="-1">useRef <a class="header-anchor" href="#useref" aria-hidden="true">#</a></h2><p>可以读取或写入，写入时不会触发渲染，当修改值不需要重新渲染时，使用<code>useRef</code>节省开销</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useRef</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// ref.current = 0</span></span>
<span class="line"></span></code></pre></div><h2 id="fragment" tabindex="-1">Fragment (&lt;&gt;...&lt;/&gt;) <a class="header-anchor" href="#fragment" aria-hidden="true">#</a></h2><p>相当于<code>Vue</code>的<code>&lt;template&gt;</code>，<code>&lt;Fragment&gt;</code>大多数情况下等同于<code>&lt;&gt;...&lt;/&gt;</code>，区别在于渲染列表时，<code>&lt;&gt;...&lt;/&gt;</code>不能设定key而<code>&lt;Fragment&gt;</code>可以</p>`,25),p=[o];function t(c,r,y,i,A,C){return e(),a("div",null,p)}const F=s(l,[["render",t]]);export{D as __pageData,F as default};
