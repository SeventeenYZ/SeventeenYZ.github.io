import{_ as e,c as o,o as c,a as d}from"./app.ce5a6efd.js";const t="/HTTP/image-20201106153032276.png",l=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"tool/HTTP.md"}'),a={name:"tool/HTTP.md"},p=d('<h4 id="http-https协议" tabindex="-1">HTTP/HTTPS协议 <a class="header-anchor" href="#http-https协议" aria-hidden="true">#</a></h4><p><code>HTTPS</code>=<code>HTTP</code>+<code>SSL</code></p><p>① 对称加密：客户端和服务端用同个密钥对数据进行加密或解密 缺点：商量密钥时可能会被窃听</p><p>② 非对称加密：服务端拥有一把公钥和一把私钥 第一步：客户端向服务端索要公钥，服务端发送公钥给客户端 第二步：客户端使用公钥进行加密，服务端用私钥进行解密 缺点：服务端无法向客户端发送数据</p><p>③ <code>HTTPS</code>采用对称加密+非对称加密的机制，商量密钥阶段用非对称加密，通信阶段用对称加密 第一步：客户端向服务端索要公钥，服务端发送公钥给客户端 第二步：客户端定义一个随机数，用公钥加密后发送给服务端，服务端使用私钥解密得到随机数 第三步：随机数作为对称加密的密钥使用 缺点：假如客户端第一次索要公钥的请求就被黑客拦截，此后黑客就能一直当中间人</p><p>解决中间人问题的办法是数字证书机构，经过该机构认证过的公钥才是可信赖的公钥，让客户端能够确定公钥是可信赖的服务器发送过来的</p><p><img src="'+t+'" alt="图片加载失败"></p><h4 id="三次握手和四次挥手" tabindex="-1">三次握手和四次挥手 <a class="header-anchor" href="#三次握手和四次挥手" aria-hidden="true">#</a></h4><p>三次握手的过程： 第一次握手：<code>A</code>向<code>B</code>发起建立连接请求：<code>A</code>——&gt;<code>B</code> 第二次握手：<code>B</code>收到<code>A</code>的请求，并且向<code>A</code>发送确认信号：<code>A</code>&lt;——<code>B</code> 第三次握手：<code>A</code>收到<code>B</code>的确认信号，并向<code>B</code>发送确认信号：<code>A</code>——&gt;<code>B</code> 目的是为了确认双方的收发能力都正常</p><p>四次挥手的过程： 第一次挥手：<code>A</code>向<code>B</code>发起断开连接请求，表示<code>A</code>没有数据要发送了：<code>A</code>——&gt;<code>B</code> 第二次挥手：<code>B</code>收到<code>A</code>的请求，并且向<code>A</code>发送确认信号：<code>A</code>&lt;——<code>B</code> 第三次挥手：<code>B</code>向<code>A</code>发送信号，请求断开连接，表示<code>B</code>没有数据要发送了：<code>A</code>&lt;——<code>B</code> 第四次挥手：<code>A</code>向<code>B</code>发送确认信号，同意断开：<code>A</code>——&gt;<code>B</code> 第二次挥手和第三次挥手不能合成一次的原因：此时<code>A</code>虽然不再发送数据了，但是还可以接收数据，<code>B</code>可能还有数据要发送给<code>A</code> 挥手次数比握手多一次的原因：在握手过程，通信只需要处理连接。而挥手过程，通信需要处理数据<code>+</code>连接</p>',10),r=[p];function s(_,n,T,i,A,h){return c(),o("div",null,r)}const P=e(a,[["render",s]]);export{l as __pageData,P as default};
