import{_ as e,c as o,o as c,a as d,b as n}from"./app.2608b0ed.js";const S=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"Cookie + Session登录","slug":"cookie-session登录","link":"#cookie-session登录","children":[]},{"level":2,"title":"token登录","slug":"token登录","link":"#token登录","children":[]},{"level":2,"title":"token续签","slug":"token续签","link":"#token续签","children":[{"level":3,"title":"有了token为什么还要cookie","slug":"有了token为什么还要cookie","link":"#有了token为什么还要cookie","children":[]}]}],"relativePath":"Tool/login.md"}'),t={name:"Tool/login.md"},i=d('<h2 id="cookie-session登录" tabindex="-1">Cookie + Session登录 <a class="header-anchor" href="#cookie-session登录" aria-hidden="true">#</a></h2><p><code>http</code>是无状态协议，客户端发起请求时与服务器建立连接，请求完成后又会断开连接，这种方式是为了节省传输时占用的连接资源，为了判断客户端的登录状态推出了<code>Cookie</code></p><p><code>Cookie</code>是服务器给客户端的一段特殊信息，客户端每次发送请求时会在请求头带上这些特殊信息</p><p>服务器对<code>Cookie</code>进行认证，需要通过<code>Session</code></p><p><code>Session</code>是一种记录客户端状态的机制，服务器在验证登录成功后，会创建<code>SessionId</code>并保存起来，并通过<code>set-cookie</code>将<code>SessionId</code>写入<code>Cookie</code>中，当客户端再次访问的时候比对<code>Cookie</code>中的<code>SessionId</code>与服务端保存的<code>SessionId</code>是否一致来验证</p><p>存在的问题：</p><p>服务端对接大量的客户端也就需要保存大量的<code>SessionId</code> 如果服务端是集群，为了同步登录态，需要将<code>SessionId</code>同步到每一台机器上</p><h2 id="token登录" tabindex="-1">token登录 <a class="header-anchor" href="#token登录" aria-hidden="true">#</a></h2><p><code>token</code>是服务端生成的一串字符串当成客户端请求的一个标识，首次登录后，服务端生成一个<code>token</code>返回给客户端，客户端自行保存，后续访问带上这个<code>token</code>来让服务器验证身份</p><h2 id="token续签" tabindex="-1">token续签 <a class="header-anchor" href="#token续签" aria-hidden="true">#</a></h2><p>通过双<code>token</code>，即<code>access token</code>和<code>refresh token</code>来实现<code>token</code>续签（<code>refresh token</code>也有的叫<code>cache token</code>）</p><p>后端为了<code>token</code>的安全性，一般会把<code>token</code>的过期时间设置得比较短，而为了避免用户频繁登录，传给客户端保存的是<code>access token</code>，当验证<code>access token</code>有效时，会根据规则取出<code>refresh token</code>判断是否存在</p><p>不存在则说明客户空闲过久，信息失效需要重新登录。存在则验证是否过期，过期会重新续签<code>token</code></p><p>例如<code>access token</code>有效期12小时，<code>refresh token</code>有效期24小时，用户如果在超过12小时但是不到24小时的时间内请求服务器则会续签<code>token</code>，超过24小时就需要重新登录</p><h3 id="有了token为什么还要cookie" tabindex="-1">有了token为什么还要cookie <a class="header-anchor" href="#有了token为什么还要cookie" aria-hidden="true">#</a></h3><p>例如token是在axios请求拦截里添加请求头Authorization：{token}，当通过location.href =&#39;文件地址&#39;下载文件，默认发起一个get请求，但是不会经过axios请求拦截器（该请求也会自动带上cookie），因此无法添加token，需要cookie以便能实现认证下载，类似的还有通过a标签下载</p>',16),s=n("p",{token:""},"不用cookie解决办法：不用cookie会比较麻烦，如果要用ajax去接收，类型改成blob，然后去下载这个资源或者后端配合，从header中获取不到就从query string(params)获取前端url带上token参数 download?token=",-1),a=[i,s];function k(r,l,h,p,_,f){return c(),o("div",null,a)}const g=e(t,[["render",k]]);export{S as __pageData,g as default};
