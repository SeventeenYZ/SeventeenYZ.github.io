[为什么不用prettier](https://antfu.me/posts/why-not-prettier-zh)

随着前端的发展，各种提升开发效率的工具层出不穷，而浏览器只识别`html`、`css`和`js`，构建需要做的事情有以下这些

代码转换：将`TypeScript`编译成`JavaScript`、将`scss`编译成`css`等

文件优化：压缩`JavaScript`、`css`、`html`代码，压缩合并图片等

代码分割：提取公共代码，提取不需要立即执行的代码让其懒加载或异步加载

热更新：监听本地源代码的变化，自动重新构建、刷新浏览器

`tree shaking`：去除没用到的代码

## Webpack

打包流程

1、读取配置

2、启动`webpack`，创建`Compiler`对象并开始解析项目

3、从入口文件（`entry`）开始，找到其导入的依赖模块，递归遍历分析，生成依赖关系树

4、对不同文件类型的文件使用对应的`loader`编译，最终转为`JavaScript`文件

5、编译过程中会通过发布订阅模式，向外抛出一些`hooks`，`webpack`的`plugin`可通过监听事件节点执行插件功能

## Webpack和Vite开发环境对比

Webpack：分析依赖 => 编译打包 => 交给本地服务进行渲染。首先分析各个模块之间的依赖，然后进行打包，在启动webpack-dev-server，浏览器请求开发服务器时，直接显示打包结果。Webpack打包之后存在的问题：随着项目体积的增大，会造成bundle体积增加，影响冷启动和热更新的速度

Vite：启动开发服务器 => 浏览器请求模块时按需动态编译显示。是先开启开发服务器，请求某个模块时再对该模块进行实时编译构建，现代浏览器本身支持ESM，会自动向依赖的Module发出请求，所以Vite就将开发环境下的模块文件作为浏览器的执行文件，而不是像Webpack进行打包后交给本地服务器

Vite启动时不需要打包，不需要分析模块间的依赖关系，不用进行编译，但是是先启动开发服务器，等浏览器请求模块时，再对模块进行编译构建（不压缩），因此首屏加载时请求模块多的时候渲染速度会比较慢

热更新方面：改动模块后，Vite只需要让浏览器重新请求该模块，Webpack则需要重新编译打包一次，但是Webpack的热更新会以当前修改的文件为入口重新打包，所有涉及到的依赖也都会被重新加载一次，因此速度也比不上Vite

## 优化

有一些核心思想是各个层面通用的：按需加载、缓存

### 网络层面

升级http2

开启g-zip压缩减少传输时间

iconfont代替图片图标：将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等，非常方便，并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小，无论是加载还是打包所消耗的资源都相对较小一些

图片优化：包括图片懒加载、适当降低图片质量、尽量用css代替图片、使用webp图片（存在兼容性问题）

减少无用的请求头数据（这个有点鸡肋）

以往http1.1时代的域名拆分、文件合并、开启keep-alive这些优化手段在http2可以丢弃掉

### 项目方面

减小构建产物大小（包括区分`package.json`中`devDependencies`和`dependencies`，开发环境的依赖不打包进生产环境的构建包）

减少编译打包时间

代码预加载和按需加载

图片使用CDN

压缩`js`和`css`文件

### 代码层面

第三方库按需引入

css嵌套最好不要超过3层，过度嵌套会导致css文件变大，影响渲染速度

事件的防抖节流

## 调试

查看返回的`json`数据大小

## 构建

合理配置`hash`，改过的文件需要更新`hash`值，这样才能保证上线后，浏览器访问没有改变的文件时能命中缓存，而改过的文件会重新请求

```js
// webpack.base.js
modules.export = {
    ...
    output: {
        path: path.resolve(__dirname, '../dist'),
        // 给js文件加上contenthash
        filename: 'js/chunk-[contenthash].js',
        clean: true,
    }
}
```

## 缓存

缓存：文件名加入hash，有效时间内用强缓存，缓存失效用协商缓存
